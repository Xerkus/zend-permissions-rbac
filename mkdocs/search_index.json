{
    "docs": [
        {
            "location": "/",
            "text": "../../README.md",
            "title": "Home"
        },
        {
            "location": "/intro/",
            "text": "Introduction\n\n\nzend-permissions-rbac provides a lightweight role-based access control (RBAC)\nimplementation based around PHP's \nRecursiveIterator\n and\n\nRecursiveIteratorIterator\n. RBAC differs from access control lists (ACL) by\nputting the emphasis on roles and their permissions rather than objects\n(resources).\n\n\nFor the purposes of this documentation:\n\n\n\n\nan \nidentity\n has one or more roles.\n\n\na \nrole\n requests access to a permission.\n\n\na \npermission\n is given to a role.\n\n\n\n\nThus, RBAC has the following model:\n\n\n\n\nmany to many relationship between \nidentities\n and \nroles\n.\n\n\nmany to many relationship between \nroles\n and \npermissions\n.\n\n\nroles\n can have a parent role.\n\n\n\n\nRoles\n\n\nTo create a role, extend the abstract class \nZend\\Permission\\Rbac\\AbstractRole\n\nor use the default role class, \nZend\\Permission\\Rbac\\Role\n. You can instantiate\na role and add it to the RBAC container or add a role directly using the RBAC\ncontainer \naddRole()\n method.\n\n\nPermissions\n\n\nEach role can have zero or more permissions and can be set directly to the role\nor by first retrieving the role from the RBAC container. Any parent role will\ninherit the permissions of their children.\n\n\nDynamic Assertions\n\n\nIn certain situations simply checking a permission key for access may not be\nenough. For example, assume two users, Foo and Bar, both have \narticle.edit\n\npermission. What's to stop Bar from editing Foo's articles? The answer is\ndynamic assertions which allow you to specify extra runtime credentials that\nmust pass for access to be granted.",
            "title": "Intro"
        },
        {
            "location": "/intro/#introduction",
            "text": "zend-permissions-rbac provides a lightweight role-based access control (RBAC)\nimplementation based around PHP's  RecursiveIterator  and RecursiveIteratorIterator . RBAC differs from access control lists (ACL) by\nputting the emphasis on roles and their permissions rather than objects\n(resources).  For the purposes of this documentation:   an  identity  has one or more roles.  a  role  requests access to a permission.  a  permission  is given to a role.   Thus, RBAC has the following model:   many to many relationship between  identities  and  roles .  many to many relationship between  roles  and  permissions .  roles  can have a parent role.",
            "title": "Introduction"
        },
        {
            "location": "/intro/#roles",
            "text": "To create a role, extend the abstract class  Zend\\Permission\\Rbac\\AbstractRole \nor use the default role class,  Zend\\Permission\\Rbac\\Role . You can instantiate\na role and add it to the RBAC container or add a role directly using the RBAC\ncontainer  addRole()  method.",
            "title": "Roles"
        },
        {
            "location": "/intro/#permissions",
            "text": "Each role can have zero or more permissions and can be set directly to the role\nor by first retrieving the role from the RBAC container. Any parent role will\ninherit the permissions of their children.",
            "title": "Permissions"
        },
        {
            "location": "/intro/#dynamic-assertions",
            "text": "In certain situations simply checking a permission key for access may not be\nenough. For example, assume two users, Foo and Bar, both have  article.edit \npermission. What's to stop Bar from editing Foo's articles? The answer is\ndynamic assertions which allow you to specify extra runtime credentials that\nmust pass for access to be granted.",
            "title": "Dynamic Assertions"
        },
        {
            "location": "/methods/",
            "text": "Methods\n\n\nZend\\Permissions\\Rbac\\AbstractIterator\n\n\nThe \nAbstractIterator\n is used as the basis for both the primary \nRbac\n class\nand the \nAbstractRole\n.\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncurrent() : RoleInterface\n\n\nReturn the current role instance.\n\n\n\n\n\n\ngetChildren() : RecursiveIterator\n\n\nReturns a recursive iterator of all children of the current role.\n\n\n\n\n\n\nhasChildren() : bool\n\n\nIndicates if the current role has children.\n\n\n\n\n\n\nkey() : int\n\n\nIndex of the current role instance.\n\n\n\n\n\n\nnext() : void\n\n\nAdvance to the next role instance.\n\n\n\n\n\n\nrewind() : void\n\n\nSeek to the first item in the iterator.\n\n\n\n\n\n\nvalid() : bool\n\n\nIs the current index valid?\n\n\n\n\n\n\n\n\nZend\\Permissions\\Rbac\\AbstractRole\n\n\nThe \nAbstractRole\n provides the base functionality required by the\n\nRoleInterface\n, and is the foundation for the \nRole\n class.\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\naddChild(string|RoleInterface $child) : void\n\n\nAdd a child role to the current instance.\n\n\n\n\n\n\naddPermission(string $name) : void\n\n\nAdd a permission for the current role.\n\n\n\n\n\n\ngetName() : string\n\n\nRetrieve the name assigned to this role.\n\n\n\n\n\n\nhasPermission(string $name) : bool\n\n\nDoes the role have the given permission?\n\n\n\n\n\n\nsetParent(RoleInterface $parent) : void\n\n\nAssign the provided role as the current role's parent.\n\n\n\n\n\n\naddParent(RoleInterface $parent) : Role\n\n\nAdd a parent role to the current instance.\n\n\n\n\n\n\ngetParent() null|RoleInterface|array\n\n\nRetrieve the current role's parent, or array of parents if more that one exists.\n\n\n\n\n\n\n\n\nZend\\Permissions\\Rbac\\AssertionInterface\n\n\nCustom assertions can be provided to \nRbac::isGranted()\n (see below); such\nassertions are provided the \nRbac\n instance on invocation.\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nassert(Rbac $rbac) : bool\n\n\nGiven an RBAC, determine if permission is granted.\n\n\n\n\n\n\n\n\nZend\\Permissions\\Rbac\\Rbac\n\n\nRbac\n is the object with which you will interact within your application in\norder to query for permissions. It extends \nAbstractIterator\n.\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\naddRole(string|RoleInterface $child, array|RoleInterface $parents = null)\n\n\nAdd a role to the RBAC. If \n$parents\n is non-null, the \n$child\n is also added to any parents provided.\n\n\n\n\n\n\ngetRole(string|RoleInterface $role) : RoleInterface\n\n\nRecursively queries the RBAC for the given role, returning it if found, and raising an exception otherwise.\n\n\n\n\n\n\nhasRole(string|RoleInterface $role) : bool\n\n\nRecursively queries the RBAC for the given role, returning \ntrue\n if found, \nfalse\n otherwise.\n\n\n\n\n\n\ngetCreateMissingRoles() : bool\n\n\nRetrieve the flag that determines whether or not \n$parent\n roles are added automatically if not present when calling \naddRole()\n.\n\n\n\n\n\n\nsetCreateMissingRoles(bool $flag) : void\n\n\nSet the flag that determines whether or not \n$parent\n roles are added automatically if not present when calling \naddRole()\n.\n\n\n\n\n\n\nisGranted(string|RoleInterface $role, string $permission, $assert = null)\n\n\nDetermine if the role has the given permission. If \n$assert\n is provided and either an \nAssertInterface\n instance or callable, it will be queried before checking against the given role.\n\n\n\n\n\n\n\n\nZend\\Permissions\\Rbac\\Role\n\n\nRole\n inherits from \nAbstractRole\n and \nAbstractIterator\n.\n\n\n\n\n\n\n\n\nMethod signature\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n__construct(string $name) : void\n\n\nCreate a new instance with the provided name.",
            "title": "Methods"
        },
        {
            "location": "/methods/#methods",
            "text": "",
            "title": "Methods"
        },
        {
            "location": "/methods/#zendpermissionsrbacabstractiterator",
            "text": "The  AbstractIterator  is used as the basis for both the primary  Rbac  class\nand the  AbstractRole .     Method signature  Description      current() : RoleInterface  Return the current role instance.    getChildren() : RecursiveIterator  Returns a recursive iterator of all children of the current role.    hasChildren() : bool  Indicates if the current role has children.    key() : int  Index of the current role instance.    next() : void  Advance to the next role instance.    rewind() : void  Seek to the first item in the iterator.    valid() : bool  Is the current index valid?",
            "title": "Zend\\Permissions\\Rbac\\AbstractIterator"
        },
        {
            "location": "/methods/#zendpermissionsrbacabstractrole",
            "text": "The  AbstractRole  provides the base functionality required by the RoleInterface , and is the foundation for the  Role  class.     Method signature  Description      addChild(string|RoleInterface $child) : void  Add a child role to the current instance.    addPermission(string $name) : void  Add a permission for the current role.    getName() : string  Retrieve the name assigned to this role.    hasPermission(string $name) : bool  Does the role have the given permission?    setParent(RoleInterface $parent) : void  Assign the provided role as the current role's parent.    addParent(RoleInterface $parent) : Role  Add a parent role to the current instance.    getParent() null|RoleInterface|array  Retrieve the current role's parent, or array of parents if more that one exists.",
            "title": "Zend\\Permissions\\Rbac\\AbstractRole"
        },
        {
            "location": "/methods/#zendpermissionsrbacassertioninterface",
            "text": "Custom assertions can be provided to  Rbac::isGranted()  (see below); such\nassertions are provided the  Rbac  instance on invocation.     Method signature  Description      assert(Rbac $rbac) : bool  Given an RBAC, determine if permission is granted.",
            "title": "Zend\\Permissions\\Rbac\\AssertionInterface"
        },
        {
            "location": "/methods/#zendpermissionsrbacrbac",
            "text": "Rbac  is the object with which you will interact within your application in\norder to query for permissions. It extends  AbstractIterator .     Method signature  Description      addRole(string|RoleInterface $child, array|RoleInterface $parents = null)  Add a role to the RBAC. If  $parents  is non-null, the  $child  is also added to any parents provided.    getRole(string|RoleInterface $role) : RoleInterface  Recursively queries the RBAC for the given role, returning it if found, and raising an exception otherwise.    hasRole(string|RoleInterface $role) : bool  Recursively queries the RBAC for the given role, returning  true  if found,  false  otherwise.    getCreateMissingRoles() : bool  Retrieve the flag that determines whether or not  $parent  roles are added automatically if not present when calling  addRole() .    setCreateMissingRoles(bool $flag) : void  Set the flag that determines whether or not  $parent  roles are added automatically if not present when calling  addRole() .    isGranted(string|RoleInterface $role, string $permission, $assert = null)  Determine if the role has the given permission. If  $assert  is provided and either an  AssertInterface  instance or callable, it will be queried before checking against the given role.",
            "title": "Zend\\Permissions\\Rbac\\Rbac"
        },
        {
            "location": "/methods/#zendpermissionsrbacrole",
            "text": "Role  inherits from  AbstractRole  and  AbstractIterator .     Method signature  Description      __construct(string $name) : void  Create a new instance with the provided name.",
            "title": "Zend\\Permissions\\Rbac\\Role"
        },
        {
            "location": "/examples/",
            "text": "Examples\n\n\nThe following is a list of common use-case examples for zend-permission-rbac.\n\n\nRoles\n\n\nExtending and adding roles via instantiation:\n\n\nuse Zend\\Permissions\\Rbac\\Rbac;\nuse Zend\\Permissions\\Rbac\\AbstractRole;\n\nclass MyRole extends AbstractRole\n{\n    // .. implementation\n}\n\n// Creating roles manually\n$foo  = new MyRole('foo');\n\n$rbac = new Rbac();\n$rbac->addRole($foo);\n\nvar_dump($rbac->hasRole('foo')); // true\n\n\n\nAdding roles directly to RBAC with the default \nZend\\Permission\\Rbac\\Role\n:\n\n\nuse Zend\\Permissions\\Rbac\\Rbac;\n\n$rbac = new Rbac();\n$rbac->addRole('foo');\n\nvar_dump($rbac->hasRole('foo')); // true\n\n\n\nHandling roles with children:\n\n\nuse Zend\\Permissions\\Rbac\\Rbac;\nuse Zend\\Permissions\\Rbac\\Role;\n\n$rbac = new Rbac();\n$foo  = new Role('foo');\n$bar  = new Role('bar');\n\n// 1 - Add a role with child role directly with instantiated classes.\n$foo->addChild($bar);\n$rbac->addRole($foo);\n\n// 2 - Same as one, only via rbac container.\n$rbac->addRole('boo', 'baz'); // baz is a parent of boo\n$rbac->addRole('baz', ['out', 'of', 'roles']); // create several parents of baz\n\n\n\nPermissions\n\n\nuse Zend\\Permissions\\Rbac\\Rbac;\nuse Zend\\Permissions\\Rbac\\Role;\n\n$rbac = new Rbac();\n$foo  = new Role('foo');\n$foo->addPermission('bar');\n\nvar_dump($foo->hasPermission('bar')); // true\n\n$rbac->addRole($foo);\n$rbac->isGranted('foo', 'bar'); // true\n$rbac->isGranted('foo', 'baz'); // false\n\n$rbac->getRole('foo')->addPermission('baz');\n$rbac->isGranted('foo', 'baz'); // true\n\n\n\nDynamic Assertions\n\n\nChecking permission using \nisGranted()\n with a class implementing\n\nZend\\Permissions\\Rbac\\AssertionInterface\n:\n\n\nuse Zend\\Permissions\\Rbac\\AssertionInterface;\nuse Zend\\Permissions\\Rbac\\Rbac;\n\nclass AssertUserIdMatches implements AssertionInterface\n{\n    protected $userId;\n    protected $article;\n\n    public function __construct($userId)\n    {\n        $this->userId = $userId;\n    }\n\n    public function setArticle($article)\n    {\n        $this->article = $article;\n    }\n\n    public function assert(Rbac $rbac)\n    {\n        if (! $this->article) {\n            return false;\n        }\n\n        return ($this->userId === $this->article->getUserId());\n    }\n}\n\n// User is assigned the foo role with id 5\n// News article belongs to userId 5\n// Jazz article belongs to userId 6\n\n$rbac = new Rbac();\n$user = $mySessionObject->getUser();\n$news = $articleService->getArticle(5);\n$jazz = $articleService->getArticle(6);\n\n$rbac->addRole($user->getRole());\n$rbac->getRole($user->getRole())->addPermission('edit.article');\n\n$assertion = new AssertUserIdMatches($user->getId());\n$assertion->setArticle($news);\n\n// true always - bad!\nif ($rbac->isGranted($user->getRole(), 'edit.article')) {\n    // hacks another user's article\n}\n\n// true for user id 5, because he belongs to write group and user id matches\nif ($rbac->isGranted($user->getRole(), 'edit.article', $assertion)) {\n    // edits his own article\n}\n\n$assertion->setArticle($jazz);\n\n// false for user id 5\nif ($rbac->isGranted($user->getRole(), 'edit.article', $assertion)) {\n    // can not edit another user's article\n}\n\n\n\nPerforming the same as above with a closure:\n\n\n// assume same variables from previous example\n\n$assertion = function($rbac) use ($user, $news) {\n    return ($user->getId() === $news->getUserId());\n};\n\n// true\nif ($rbac->isGranted($user->getRole(), 'edit.article', $assertion)) {\n    // edits his own article\n}",
            "title": "Examples"
        },
        {
            "location": "/examples/#examples",
            "text": "The following is a list of common use-case examples for zend-permission-rbac.",
            "title": "Examples"
        },
        {
            "location": "/examples/#roles",
            "text": "Extending and adding roles via instantiation:  use Zend\\Permissions\\Rbac\\Rbac;\nuse Zend\\Permissions\\Rbac\\AbstractRole;\n\nclass MyRole extends AbstractRole\n{\n    // .. implementation\n}\n\n// Creating roles manually\n$foo  = new MyRole('foo');\n\n$rbac = new Rbac();\n$rbac->addRole($foo);\n\nvar_dump($rbac->hasRole('foo')); // true  Adding roles directly to RBAC with the default  Zend\\Permission\\Rbac\\Role :  use Zend\\Permissions\\Rbac\\Rbac;\n\n$rbac = new Rbac();\n$rbac->addRole('foo');\n\nvar_dump($rbac->hasRole('foo')); // true  Handling roles with children:  use Zend\\Permissions\\Rbac\\Rbac;\nuse Zend\\Permissions\\Rbac\\Role;\n\n$rbac = new Rbac();\n$foo  = new Role('foo');\n$bar  = new Role('bar');\n\n// 1 - Add a role with child role directly with instantiated classes.\n$foo->addChild($bar);\n$rbac->addRole($foo);\n\n// 2 - Same as one, only via rbac container.\n$rbac->addRole('boo', 'baz'); // baz is a parent of boo\n$rbac->addRole('baz', ['out', 'of', 'roles']); // create several parents of baz",
            "title": "Roles"
        },
        {
            "location": "/examples/#permissions",
            "text": "use Zend\\Permissions\\Rbac\\Rbac;\nuse Zend\\Permissions\\Rbac\\Role;\n\n$rbac = new Rbac();\n$foo  = new Role('foo');\n$foo->addPermission('bar');\n\nvar_dump($foo->hasPermission('bar')); // true\n\n$rbac->addRole($foo);\n$rbac->isGranted('foo', 'bar'); // true\n$rbac->isGranted('foo', 'baz'); // false\n\n$rbac->getRole('foo')->addPermission('baz');\n$rbac->isGranted('foo', 'baz'); // true",
            "title": "Permissions"
        },
        {
            "location": "/examples/#dynamic-assertions",
            "text": "Checking permission using  isGranted()  with a class implementing Zend\\Permissions\\Rbac\\AssertionInterface :  use Zend\\Permissions\\Rbac\\AssertionInterface;\nuse Zend\\Permissions\\Rbac\\Rbac;\n\nclass AssertUserIdMatches implements AssertionInterface\n{\n    protected $userId;\n    protected $article;\n\n    public function __construct($userId)\n    {\n        $this->userId = $userId;\n    }\n\n    public function setArticle($article)\n    {\n        $this->article = $article;\n    }\n\n    public function assert(Rbac $rbac)\n    {\n        if (! $this->article) {\n            return false;\n        }\n\n        return ($this->userId === $this->article->getUserId());\n    }\n}\n\n// User is assigned the foo role with id 5\n// News article belongs to userId 5\n// Jazz article belongs to userId 6\n\n$rbac = new Rbac();\n$user = $mySessionObject->getUser();\n$news = $articleService->getArticle(5);\n$jazz = $articleService->getArticle(6);\n\n$rbac->addRole($user->getRole());\n$rbac->getRole($user->getRole())->addPermission('edit.article');\n\n$assertion = new AssertUserIdMatches($user->getId());\n$assertion->setArticle($news);\n\n// true always - bad!\nif ($rbac->isGranted($user->getRole(), 'edit.article')) {\n    // hacks another user's article\n}\n\n// true for user id 5, because he belongs to write group and user id matches\nif ($rbac->isGranted($user->getRole(), 'edit.article', $assertion)) {\n    // edits his own article\n}\n\n$assertion->setArticle($jazz);\n\n// false for user id 5\nif ($rbac->isGranted($user->getRole(), 'edit.article', $assertion)) {\n    // can not edit another user's article\n}  Performing the same as above with a closure:  // assume same variables from previous example\n\n$assertion = function($rbac) use ($user, $news) {\n    return ($user->getId() === $news->getUserId());\n};\n\n// true\nif ($rbac->isGranted($user->getRole(), 'edit.article', $assertion)) {\n    // edits his own article\n}",
            "title": "Dynamic Assertions"
        }
    ]
}